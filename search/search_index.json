{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Telegram Bot Swift Docs You can choose the version of documentation from the sidebar.","title":"Welcome"},{"location":"#welcome-to-telegram-bot-swift-docs","text":"You can choose the version of documentation from the sidebar.","title":"Welcome to Telegram Bot Swift Docs"},{"location":"versions/v0_X/","text":"Telegram Bot Swift SDK Wiki Warning This version is no longer supported and uses Swift 3/4. Please upgrade to version 2.0 or later Documentation Building and running the example projects Creating a new bot API Introduction Parsing Commands Links Bots: an introduction for developers Telegram Bot API","title":"Welcome"},{"location":"versions/v0_X/#telegram-bot-swift-sdk-wiki","text":"Warning This version is no longer supported and uses Swift 3/4. Please upgrade to version 2.0 or later","title":"Telegram Bot Swift SDK Wiki"},{"location":"versions/v0_X/#documentation","text":"Building and running the example projects Creating a new bot API Introduction Parsing Commands","title":"Documentation"},{"location":"versions/v0_X/#links","text":"Bots: an introduction for developers Telegram Bot API","title":"Links"},{"location":"versions/v0_X/api-introduction/","text":"API introduction Intro SDK hides most of the complexity from you. It fetches messages, parses them, constructs responses, handles errors and reconnections and so on. The defaults should be suitable in most cases. There's also a lower level API. In a typical bot you just receive a command and react to it somehow. All else is done by the library. If multiple bots are in a group, users can add bot usernames to commands in order to avoid confusion, for example: /command@nameofmy_bot . This is also handled by the library, you receive the command with bot username deleted from it. So, /command@nameofmy_bot argument becomes /command argument . Commands addressed to other bots are ignored. Router class can be used for splitting a command into parts and calling appropriate handler functions. More on it in Parsing the commands section. Bot fetches it's username from Telegram by issuing a /getMe request on start. Sync and async methods Most API methods have two versions: synchronous and asynchronous. They are distinguished by their suffix, for example: respondSync and respondAsync . Synchronous methods block until the operation is completed. Asynchronous methods accept an optional completion handler which will be called when the operation is completed. For example, to send two messages to user guaranteeing the order in which they arrive you can do either: bot . respondSync ( \"Message 1\" ) // blocks until the message is sent bot . respondSync ( \"Message 2\" ) or bot . respondAsync ( \"Message 1\" ) { bot . respondAsync ( \"Message 2\" ) { } } // execution continues immediately It's better to use the second approach because the server can process and respond to other messages and won't block waiting for confirmation. Completion handler is called on the main thread by default. For simplicity, it's possible to synchronously process messages, but respond asynchronously to avoid blocking the processing of the next message. So, a typical bot's main loop looks like this: while let message = bot . nextMessageSync () { if let command = bot . lastCommand { bot . respondAsync ( \"Hi \\( bot . lastMessage . from . firstName ) ! You said: \\( command ) . \\n \" ) } } Next: Parsing the commands","title":"API introduction"},{"location":"versions/v0_X/api-introduction/#api-introduction","text":"","title":"API introduction"},{"location":"versions/v0_X/api-introduction/#intro","text":"SDK hides most of the complexity from you. It fetches messages, parses them, constructs responses, handles errors and reconnections and so on. The defaults should be suitable in most cases. There's also a lower level API. In a typical bot you just receive a command and react to it somehow. All else is done by the library. If multiple bots are in a group, users can add bot usernames to commands in order to avoid confusion, for example: /command@nameofmy_bot . This is also handled by the library, you receive the command with bot username deleted from it. So, /command@nameofmy_bot argument becomes /command argument . Commands addressed to other bots are ignored. Router class can be used for splitting a command into parts and calling appropriate handler functions. More on it in Parsing the commands section. Bot fetches it's username from Telegram by issuing a /getMe request on start.","title":"Intro"},{"location":"versions/v0_X/api-introduction/#sync-and-async-methods","text":"Most API methods have two versions: synchronous and asynchronous. They are distinguished by their suffix, for example: respondSync and respondAsync . Synchronous methods block until the operation is completed. Asynchronous methods accept an optional completion handler which will be called when the operation is completed. For example, to send two messages to user guaranteeing the order in which they arrive you can do either: bot . respondSync ( \"Message 1\" ) // blocks until the message is sent bot . respondSync ( \"Message 2\" ) or bot . respondAsync ( \"Message 1\" ) { bot . respondAsync ( \"Message 2\" ) { } } // execution continues immediately It's better to use the second approach because the server can process and respond to other messages and won't block waiting for confirmation. Completion handler is called on the main thread by default. For simplicity, it's possible to synchronously process messages, but respond asynchronously to avoid blocking the processing of the next message. So, a typical bot's main loop looks like this: while let message = bot . nextMessageSync () { if let command = bot . lastCommand { bot . respondAsync ( \"Hi \\( bot . lastMessage . from . firstName ) ! You said: \\( command ) . \\n \" ) } } Next: Parsing the commands","title":"Sync and async methods"},{"location":"versions/v0_X/creating-a-new-bot/","text":"Creating a new bot Create the project Create a directory for the project, we'll call the bot todo-bot : mkdir todo-bot cd todo-bot swift package init --type executable We now have the following project structure: \u251c\u2500\u2500 Package.swift \u251c\u2500\u2500 Sources \u2502 \u2514\u2500\u2500 todo-bot \u2502 \u2514\u2500\u2500 main.swift \u2514\u2500\u2500 Tests Edit Package.swift to look like this: import PackageDescription let package = Package ( name : \"todo-bot\" , products : [ // Products define the executables and libraries produced by a package, and make them visible to other packages. . executable ( name : \"todo-bot\" , targets : [ \"todo-bot\" ]), ], dependencies : [ // Dependencies declare other packages that this package depends on. // .package(url: /* package url */, from: \"1.0.0\"), . package ( url : \"https://github.com/zmeyc/telegram-bot-swift.git\" , . branch ( \"dev\" )), ], targets : [ // Targets are the basic building blocks of a package. A target can define a module or a test suite. // Targets can depend on other targets in this package, and on products in packages which this package depends on. . target ( name : \"hello-bot\" , dependencies : [ \"TelegramBotSDK\" ]), ] ) Run swift build : Fetching https://github.com/zmeyc/telegram-bot-swift.git Fetching https://github.com/zmeyc/CCurl.git Cloning https://github.com/zmeyc/telegram-bot-swift.git Resolving https://github.com/zmeyc/telegram-bot-swift.git at dev Cloning https://github.com/zmeyc/CCurl.git Resolving https://github.com/zmeyc/CCurl.git at 0 .0.2 Compile Swift Module 'TelegramBotSDK' ( 195 sources ) Compile Swift Module 'todo_bot' ( 1 sources ) Linking ./.build/x86_64-apple-macosx10.10/debug/todo-bot Try running .build/x86_64-apple-macosx10.10/debug/todo-bot : Hello, world! Create Xcode project Working from command-line without autocomplete is not very convenient. To create Xcode project, run: swift package generate-xcodeproj This will produce todo-bot.xcodeproj . Open it in Xcode and switch scheme to the bottom one: Build the project and run it. Create a simple bot Edit Sources/main.swift to look like this: import TelegramBot let bot = TelegramBot ( token : \"TOKEN\" ) while let update = bot . nextUpdateSync () { guard let from = message . from else { ... } if let message = update . message , let text = message . text , let from = message . from { bot . sendMessageAsync ( chat_id : message . from . id , text : \"Hi \\( from . first_name ) ! You said: \\( text ) . \\n \" ) } } fatalError ( \"Server stopped due to error: \\( bot . lastError ) \" ) Replace TOKEN with the token obtained from BotFather . Run swift build . If there are no compilation errors, run .build/x86_64-apple-macosx10.10/debug/todo-bot . If you get fatal error: Unable to fetch bot information , verify that the token is correct. Otherwise, the bot is ready to accept commands. Find your bot in Telegram and send him something. Congratulations, you've just created a simple bot! Next: API Introduction","title":"Creating a new bot"},{"location":"versions/v0_X/creating-a-new-bot/#creating-a-new-bot","text":"","title":"Creating a new bot"},{"location":"versions/v0_X/creating-a-new-bot/#create-the-project","text":"Create a directory for the project, we'll call the bot todo-bot : mkdir todo-bot cd todo-bot swift package init --type executable We now have the following project structure: \u251c\u2500\u2500 Package.swift \u251c\u2500\u2500 Sources \u2502 \u2514\u2500\u2500 todo-bot \u2502 \u2514\u2500\u2500 main.swift \u2514\u2500\u2500 Tests Edit Package.swift to look like this: import PackageDescription let package = Package ( name : \"todo-bot\" , products : [ // Products define the executables and libraries produced by a package, and make them visible to other packages. . executable ( name : \"todo-bot\" , targets : [ \"todo-bot\" ]), ], dependencies : [ // Dependencies declare other packages that this package depends on. // .package(url: /* package url */, from: \"1.0.0\"), . package ( url : \"https://github.com/zmeyc/telegram-bot-swift.git\" , . branch ( \"dev\" )), ], targets : [ // Targets are the basic building blocks of a package. A target can define a module or a test suite. // Targets can depend on other targets in this package, and on products in packages which this package depends on. . target ( name : \"hello-bot\" , dependencies : [ \"TelegramBotSDK\" ]), ] ) Run swift build : Fetching https://github.com/zmeyc/telegram-bot-swift.git Fetching https://github.com/zmeyc/CCurl.git Cloning https://github.com/zmeyc/telegram-bot-swift.git Resolving https://github.com/zmeyc/telegram-bot-swift.git at dev Cloning https://github.com/zmeyc/CCurl.git Resolving https://github.com/zmeyc/CCurl.git at 0 .0.2 Compile Swift Module 'TelegramBotSDK' ( 195 sources ) Compile Swift Module 'todo_bot' ( 1 sources ) Linking ./.build/x86_64-apple-macosx10.10/debug/todo-bot Try running .build/x86_64-apple-macosx10.10/debug/todo-bot : Hello, world!","title":"Create the project"},{"location":"versions/v0_X/creating-a-new-bot/#create-xcode-project","text":"Working from command-line without autocomplete is not very convenient. To create Xcode project, run: swift package generate-xcodeproj This will produce todo-bot.xcodeproj . Open it in Xcode and switch scheme to the bottom one: Build the project and run it.","title":"Create Xcode project"},{"location":"versions/v0_X/creating-a-new-bot/#create-a-simple-bot","text":"Edit Sources/main.swift to look like this: import TelegramBot let bot = TelegramBot ( token : \"TOKEN\" ) while let update = bot . nextUpdateSync () { guard let from = message . from else { ... } if let message = update . message , let text = message . text , let from = message . from { bot . sendMessageAsync ( chat_id : message . from . id , text : \"Hi \\( from . first_name ) ! You said: \\( text ) . \\n \" ) } } fatalError ( \"Server stopped due to error: \\( bot . lastError ) \" ) Replace TOKEN with the token obtained from BotFather . Run swift build . If there are no compilation errors, run .build/x86_64-apple-macosx10.10/debug/todo-bot . If you get fatal error: Unable to fetch bot information , verify that the token is correct. Otherwise, the bot is ready to accept commands. Find your bot in Telegram and send him something. Congratulations, you've just created a simple bot! Next: API Introduction","title":"Create a simple bot"},{"location":"versions/v0_X/custom-keyboard/","text":"How to create a Custom Keyboard A custom keyboard can be activated like this: router [ \"/start\" ] = { ( context : Context ) -> () in context . respondAsync ( \"Hello there, \\( context . message . from . first_name ) ! Nice to meet you!\" ) } Add this code to the router function: let markup = ReplyKeyboardMarkup () context . respondAsync ( \"Here is a keyboard\" , parameters : [ \"reply_markup\" : markup ]) let button1 = KeyboardButton () button1 . text = \"Any Text\" let button2 = KeyboardButton () button2 . text = \"AnyText\" markup . keyboardButtons = [ [ button1 , button2 ] ] context . respondAsync ( \"It's pretty cool\" , parameters : [ \"reply_markup\" : markup ]) Let's analyze this code let markup = ReplyKeyboardMarkup () context . respondAsync ( \"Here is a keyboard\" , parameters : [ \"reply_markup\" : markup ]) This code is necessary and gives the user a custom keyboard let button1 = KeyboardButton () button1 . text = \"Any Text\" let button2 = KeyboardButton () button2 . text = \"AnyText\" These lines of code can be played around with. Make your own text and add endless amount of buttons! markup . keyboardButtons = [ [ button1 , button2 ] ] This can also be messed around with! This is the arrangement of your buttons! Currently it has 2 buttons side by side horizontally. Play around! Now, play around and create awesome keyboards!","title":"Custom keyboard"},{"location":"versions/v0_X/custom-keyboard/#how-to-create-a-custom-keyboard","text":"A custom keyboard can be activated like this: router [ \"/start\" ] = { ( context : Context ) -> () in context . respondAsync ( \"Hello there, \\( context . message . from . first_name ) ! Nice to meet you!\" ) } Add this code to the router function: let markup = ReplyKeyboardMarkup () context . respondAsync ( \"Here is a keyboard\" , parameters : [ \"reply_markup\" : markup ]) let button1 = KeyboardButton () button1 . text = \"Any Text\" let button2 = KeyboardButton () button2 . text = \"AnyText\" markup . keyboardButtons = [ [ button1 , button2 ] ] context . respondAsync ( \"It's pretty cool\" , parameters : [ \"reply_markup\" : markup ])","title":"How to create a Custom Keyboard"},{"location":"versions/v0_X/custom-keyboard/#lets-analyze-this-code","text":"let markup = ReplyKeyboardMarkup () context . respondAsync ( \"Here is a keyboard\" , parameters : [ \"reply_markup\" : markup ]) This code is necessary and gives the user a custom keyboard let button1 = KeyboardButton () button1 . text = \"Any Text\" let button2 = KeyboardButton () button2 . text = \"AnyText\" These lines of code can be played around with. Make your own text and add endless amount of buttons! markup . keyboardButtons = [ [ button1 , button2 ] ] This can also be messed around with! This is the arrangement of your buttons! Currently it has 2 buttons side by side horizontally. Play around! Now, play around and create awesome keyboards!","title":"Let's analyze this code"},{"location":"versions/v0_X/examples/","text":"Examples Bots There are two example projects available: Examples/hello-bot - a trivial bot which responds to /greet command. Examples/word-reverse-bot - demonstrates how to handle start and stop requests, keep session state and parse command arguments. Behaves differently in private and group chats. Uses a router and a controller. TBD: an example using an SQLite database. Building a bot Let's build the second example. git clone https://github.com/zmeyc/telegram-bot-swift.git cd telegram-bot-swift/Examples/word-reverse-bot swift build If everything is correct, you will see: Cloning /Users/user/Temp/telegram-bot-swift Resolved version: 0 .2.1 Cloning https://github.com/IBM-Swift/SwiftyJSON.git Resolved version: 6 .0.0 Compiling Swift Module 'SwiftyJSON' ( 3 sources ) Compiling Swift Module 'TelegramBot' ( 46 sources ) Compiling Swift Module 'wordreversebot' ( 1 sources ) Linking .build/debug/word-reverse-bot Storing the token in source code is not a good idea, so there are two options of passing the token to bot: Via environment variable: Add the bot's token to ~/.profile : export WORD_REVERSE_BOT_TOKEN=\"TOKEN\" Replace TOKEN with the token obtained from BotFather . And reload the environment: source ~/.profile By storing the token in a file: echo \"TOKEN\" > WORD_REVERSE_BOT_TOKEN Run the bot .build / debug / word-reverse-bot Add your bot in Telegram, and play with it: Next: Creating a new bot","title":"Building and running the example projects"},{"location":"versions/v0_X/examples/#examples","text":"","title":"Examples"},{"location":"versions/v0_X/examples/#bots","text":"There are two example projects available: Examples/hello-bot - a trivial bot which responds to /greet command. Examples/word-reverse-bot - demonstrates how to handle start and stop requests, keep session state and parse command arguments. Behaves differently in private and group chats. Uses a router and a controller. TBD: an example using an SQLite database.","title":"Bots"},{"location":"versions/v0_X/examples/#building-a-bot","text":"Let's build the second example. git clone https://github.com/zmeyc/telegram-bot-swift.git cd telegram-bot-swift/Examples/word-reverse-bot swift build If everything is correct, you will see: Cloning /Users/user/Temp/telegram-bot-swift Resolved version: 0 .2.1 Cloning https://github.com/IBM-Swift/SwiftyJSON.git Resolved version: 6 .0.0 Compiling Swift Module 'SwiftyJSON' ( 3 sources ) Compiling Swift Module 'TelegramBot' ( 46 sources ) Compiling Swift Module 'wordreversebot' ( 1 sources ) Linking .build/debug/word-reverse-bot Storing the token in source code is not a good idea, so there are two options of passing the token to bot:","title":"Building a bot"},{"location":"versions/v0_X/examples/#via-environment-variable","text":"Add the bot's token to ~/.profile : export WORD_REVERSE_BOT_TOKEN=\"TOKEN\" Replace TOKEN with the token obtained from BotFather . And reload the environment: source ~/.profile","title":"Via environment variable:"},{"location":"versions/v0_X/examples/#by-storing-the-token-in-a-file","text":"echo \"TOKEN\" > WORD_REVERSE_BOT_TOKEN","title":"By storing the token in a file:"},{"location":"versions/v0_X/examples/#run-the-bot","text":".build / debug / word-reverse-bot Add your bot in Telegram, and play with it: Next: Creating a new bot","title":"Run the bot"},{"location":"versions/v0_X/parsing-commands/","text":"Parsing the commands Ignoring commands addressed to other bots in group chats For fetching the messages, use bot.nextMessageSync() helper method. It will return the fetched message and will also set bot.lastMessage to the last fetched message and bot.lastCommand to the last user command, if any. If bot.lastCommand is nil , then the message is a file attachment or another media type. When instance of TelegramBot class is constructed, it issues /getMe request and fetches the bot's name. This name is then used to distinguish this bot's commands from other bots in group chats. Messages addressed to other bots will be silently ignored unless you pass onlyMyMessages: false flag to nextMessageSync() . Constructing the router Router maps commands to their handler functions. let router = Router ( bot ) router [ \"command1\" ] = handler1 router [ \"command2\" ] = handler2 ... router . process ( command ) If user passes more arguments than command handler expects, a warning will be issued. You can customize this behavior by passing your own partial match handler to router: func partialMatchHandler ( args : Arguments ) -> Bool { bot . respondAsync ( \"Part of your input was ignored: \\( args . scanRestOfString ()) \" ) return true } router . partialMatch = partialMatchHangler So, for example, if we have a command swap which expects two arguments, but user types: /swap aaa bbb ccc , he will see: bbb aaa Part of your input was ignored: ccc If the command is not found, a warning will also be issued. This also can be customized: func unknownCommandHandler ( args : Arguments ) -> Bool { guard bot . lastMessage . chat . type == . privateChat else { return false } guard session . started else { bot . respondAsync ( \"Bot is inactive, please type /start\" ) return true } bot . respondAsync ( \"Unknown command. /help\" ) return true } router . unknownCommand = unknownCommandHandler Of course, you can also pass closures or class methods to router. Adding paths to router Any bot typically processes at least these 4 commands: router [ \"start\" ] = controller . start router [ \"stop\" ] = controller . stop router [ \"help\" ] = controller . help router [ \"settings\" ] = controller . settings Command name is processed differently in private and group chats. In private chats slash is optional. start matches /start as well as start . It group chats it only matches /start . If you don't want optional slash in private chat, pass a slash option: router [ \"mycommand\" , slash : . Required ] = controller . myHandler Commands with arguments Words can be captured and then processed by using a scanWord method. router [ \"process_word\" ] = controller . processWord ... class Controller { func processWord ( args : Arguments ) { guard let word = args . scanWord () else { bot . respondAsync ( \"Expected argument\" ) return } bot . respondAsync ( \"You said: \\( word ) \" ) } } To split string into many words, use args.scanWords() . let words = args . scanWords () for word in words { ... } Check Arguments.swift source code for more parsing options. Internally it uses NSScanner, so it's methods can be used as well. Make sure to fetch all the arguments, otherwise partialMatchHandler will come into play. There's also args.scanRestOfString() method which captures rest of string as a single string. Handler functions Any function, class method or a closure can be used as a handler. The following signatures are supported: () -> () Simple handler. Treats the command as processed. () -> Bool Cancellable handler. Return true if the command was processed, false to continue matching other rules. ( args : Arguments ) -> () ( args : Arguments ) -> Bool Handler taking the captured arguments. Extract arguments by calling corresponding methods of args . () throws -> () () throws -> Bool ( args : Arguments ) throws -> () ( args : Arguments ) throws -> Bool Throwing versions of the above. These just pass the exception your code raises to the top. Surround router.process(command) with do {} catch {} if you use them. More details are available in Router's documentation (to be done, please check the SDK source until then). Back to Wiki Home","title":"Parsing commands"},{"location":"versions/v0_X/parsing-commands/#parsing-the-commands","text":"","title":"Parsing the commands"},{"location":"versions/v0_X/parsing-commands/#ignoring-commands-addressed-to-other-bots-in-group-chats","text":"For fetching the messages, use bot.nextMessageSync() helper method. It will return the fetched message and will also set bot.lastMessage to the last fetched message and bot.lastCommand to the last user command, if any. If bot.lastCommand is nil , then the message is a file attachment or another media type. When instance of TelegramBot class is constructed, it issues /getMe request and fetches the bot's name. This name is then used to distinguish this bot's commands from other bots in group chats. Messages addressed to other bots will be silently ignored unless you pass onlyMyMessages: false flag to nextMessageSync() .","title":"Ignoring commands addressed to other bots in group chats"},{"location":"versions/v0_X/parsing-commands/#constructing-the-router","text":"Router maps commands to their handler functions. let router = Router ( bot ) router [ \"command1\" ] = handler1 router [ \"command2\" ] = handler2 ... router . process ( command ) If user passes more arguments than command handler expects, a warning will be issued. You can customize this behavior by passing your own partial match handler to router: func partialMatchHandler ( args : Arguments ) -> Bool { bot . respondAsync ( \"Part of your input was ignored: \\( args . scanRestOfString ()) \" ) return true } router . partialMatch = partialMatchHangler So, for example, if we have a command swap which expects two arguments, but user types: /swap aaa bbb ccc , he will see: bbb aaa Part of your input was ignored: ccc If the command is not found, a warning will also be issued. This also can be customized: func unknownCommandHandler ( args : Arguments ) -> Bool { guard bot . lastMessage . chat . type == . privateChat else { return false } guard session . started else { bot . respondAsync ( \"Bot is inactive, please type /start\" ) return true } bot . respondAsync ( \"Unknown command. /help\" ) return true } router . unknownCommand = unknownCommandHandler Of course, you can also pass closures or class methods to router.","title":"Constructing the router"},{"location":"versions/v0_X/parsing-commands/#adding-paths-to-router","text":"Any bot typically processes at least these 4 commands: router [ \"start\" ] = controller . start router [ \"stop\" ] = controller . stop router [ \"help\" ] = controller . help router [ \"settings\" ] = controller . settings Command name is processed differently in private and group chats. In private chats slash is optional. start matches /start as well as start . It group chats it only matches /start . If you don't want optional slash in private chat, pass a slash option: router [ \"mycommand\" , slash : . Required ] = controller . myHandler","title":"Adding paths to router"},{"location":"versions/v0_X/parsing-commands/#commands-with-arguments","text":"Words can be captured and then processed by using a scanWord method. router [ \"process_word\" ] = controller . processWord ... class Controller { func processWord ( args : Arguments ) { guard let word = args . scanWord () else { bot . respondAsync ( \"Expected argument\" ) return } bot . respondAsync ( \"You said: \\( word ) \" ) } } To split string into many words, use args.scanWords() . let words = args . scanWords () for word in words { ... } Check Arguments.swift source code for more parsing options. Internally it uses NSScanner, so it's methods can be used as well. Make sure to fetch all the arguments, otherwise partialMatchHandler will come into play. There's also args.scanRestOfString() method which captures rest of string as a single string.","title":"Commands with arguments"},{"location":"versions/v0_X/parsing-commands/#handler-functions","text":"Any function, class method or a closure can be used as a handler. The following signatures are supported: () -> () Simple handler. Treats the command as processed. () -> Bool Cancellable handler. Return true if the command was processed, false to continue matching other rules. ( args : Arguments ) -> () ( args : Arguments ) -> Bool Handler taking the captured arguments. Extract arguments by calling corresponding methods of args . () throws -> () () throws -> Bool ( args : Arguments ) throws -> () ( args : Arguments ) throws -> Bool Throwing versions of the above. These just pass the exception your code raises to the top. Surround router.process(command) with do {} catch {} if you use them. More details are available in Router's documentation (to be done, please check the SDK source until then). Back to Wiki Home","title":"Handler functions"},{"location":"versions/v2_0/","text":"Version 2.0","title":"Welcome"},{"location":"versions/v2_0/#version-20","text":"","title":"Version 2.0"}]}